
%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Allocators Implemented}
\label{sec:impl}

\subsection{Leslie Aldrige's allocator}
I began first by trying to understand the allocator written by Leslie Aldrige  \cite{Aldridge08} to get an idea about the implementation of allocators. This implementation is based on the first fit method, using a free list.

By testing the code, I've noticed several bugs in his implementation.\marginpar{DETAILS!!!}.
For example, a first problem is ...

I've fixed this problem by ...

The final code is presented in Appendix~\ref{app:leslie}.


\subsection{First version}
This first implementation is based on the first fit method with early coalescing. 
The code is presented in Appendix~\ref{app:first}.

The header has a size field and a next free chunk field, as explained in Section~\ref{sec:impl}.
\begin{lstlisting}[style=cstyle]
typedef struct header
{
  size_t size;			
  struct header *fnx;
} header;
\end{lstlisting}

The field \code{size} is equal to the quotient by the \code{header}'s size (constant \code{BLOCK_SIZE}) of the chunk's size.
Therefore, at allocation, the size requested for the free chunk is obtained by rounding the parameter \code{size} of \code{malloc} to the smallest multiple of \code{header} size (constant \code{BLOCK_SIZE}) plus 1:
\begin{lstlisting}[style=cstyle]
size_t rsize = (size / BLOCK_SIZE + 1) + 1; 
rsize = ((rsize & 1) == 1) ? rsize + 1 : rsize;
\end{lstlisting}

The early coalescing is implemented in \code{free}.
As soon as a chunk is released, checks are made to merge the contiguous free chunks.\marginpar{DETAILS!!!}.

\subsection{Second version}
This second implementation is based on the best fit method with early coalescing. 
The code is presented in Appendix~\ref{app:second}.

The code is very similar to the one of the first version except the scan loop where the best fit is computed.\marginpar{DETAILS!!!}


\subsection{Third version}
This third implementation is based on the first fit method with a free list. 
The code is presented in Appendix~\ref{app:third}.

This version is the same as the first version except that the code of allocation and release has been refactored in several functions (search a chunk, coalescing).
IT IS NOT CLEAR WHAT IS NEW HERE!!\marginpar{DETAILS!!!}


%----------------------------------------------------------------------------------------
%	SECTION
%----------------------------------------------------------------------------------------

\section{Unit Tests for Allocators}
\label{sec:test}
The purpose of unit tests is to verify the expected behavior of a function with respect to a given specification. Here the lack of precise specification forces us to define requirements of these functions, what behaviors are expected or not.

One of the goals of this internship is to conduct a series of tests on the different implementations of the \code{malloc()} and \code{free()} functions. As a result, we will first carry out functional tests and subsequently cover tests (test of instruction and condition, decision or MCDC).
The tests written are included in Appendix~\ref{app:first}.\marginpar{This part is clearly not finished.}

\subsection{Functional tests}

The functional tests consist of a call for each function and the definition of the expected answers. The individual tests will be performed out of any context of use while the test suites will verify a succession of several orders.

\subsubsection{Test of \code{malloc}}
In this test, we try to do some kind of dynamic allocation to make sure that it works properly and then we check that the heap start and the break are not \code{NULL}.

\subsubsection{Test of \code{free}}
In this test, we try to do some dynamic allocation and we release the memory and then we try to see the state of the block to ensure the proper functioning of the function.


\subsection{Coverage tests}

For the coverage tests, we will first perform tests on the functions in individual ways, out of any context of use and those for each of the functions present.
Then we will perform the tests in a context of use with a succession of function call.

\subsubsection{Statement Coverage}
In this test, we try to check all the main lines of the code. We first check that heap start and heap end are \code{NULL} before making an allocation then we check that heap start and heap end are not \code{NULL} and we release the allocated memory.

\subsubsection{MC/DC cover}
In software testing, the modified condition/decision coverage (MC/DC) is a code coverage criterion that requires all of the below during testing:
\begin{enumerate}
\item Each entry and exit point is invoked
\item Each decision takes every possible outcome
\item Each condition in a decision takes every possible outcome
\item Each condition in a decision is shown to independently affect the outcome of the decision.
\end{enumerate}

In this test, I made several malloc and free to make sure that the merge blocks, the algorithm used and all the conditions were respected.
